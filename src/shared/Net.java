package shared;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import java.io.Closeable;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static shared.IO.println;

public class Net implements Closeable {
    public static final int PORT = 46352;

    // packet headers
    public static final int SHOUT = 0;
    public static final int CONTROLLER_UPDATE = 1;
    public static final int CAR_UPDATE_RECEIVED = 2;

    private final String broadcastIp;
    private final HashMap<Byte, Long> packetId2millis = new HashMap<>();
    private final Cache<InetSocketAddress, String> peer2name =
            CacheBuilder.newBuilder()
                    .maximumSize(1000)
                    .expireAfterWrite(60, TimeUnit.SECONDS)
                    .build();

    private final Udp udp;

    public Net(final String name, final String broadcastIp) throws IOException {
        this.broadcastIp = broadcastIp;

        udp = new Udp(PORT) {
            protected void onReceive(InetSocketAddress from, byte[] bytes) {
                if (bytes.length == 0) {
                    println("! Got empty packet");
                } else {
                    switch (bytes[0]) {
                        case SHOUT:
                            byte len = bytes[1];
                            String name = new String(bytes, 2, len, Charset.forName("UTF-8"));
                            peer2name.put(from, name);
                            break;

                        case CONTROLLER_UPDATE:
                            if (bytes.length != 4) {
                                println("! Got invalid packet: " + Udp.toString(bytes));
                            } else {
                                byte id = bytes[1];
                                byte steering = bytes[2];
                                byte speed = bytes[3];

                                car_updateReceived(from, id);
                            }
                            break;

                        case CAR_UPDATE_RECEIVED:
                            if (bytes.length != 2) {
                                println("! Got invalid packet: " + Udp.toString(bytes));
                            } else {
                                byte id = bytes[1];

                                // TODO count missing packets
                                // TODO remove timed-out ids by checking if time delta in insane

                                long now = System.currentTimeMillis();
                                if (packetId2millis.containsKey(id)) {
                                    long then = packetId2millis.get(id);
                                    println("~ " + (now - then));
                                } else {
                                    println("! Got pong from unknown id: " + id);
                                }
                            }
                            break;

                        default:
                            println("! Got unknown packet: " + Udp.toString(bytes));
                            break;

                    }
                }
            }
        };

        // shouter
        try {
            // prepare "shout" packet
            byte[] nameBytes = name.substring(0, Math.min(64, name.length())).getBytes("UTF-8");
            final byte[] shoutBytes = new byte[nameBytes.length + 2];
            shoutBytes[0] = SHOUT;
            shoutBytes[1] = (byte) nameBytes.length;
            System.arraycopy(nameBytes, 0, shoutBytes, 2, nameBytes.length);

            new Thread() {
                public void run() {
                    Sleeper s = new Sleeper();
                    while (udp.isRunning()) {
                        both_shout(shoutBytes);
                        s.sleep(1000);
                    }
                }
            }.start();
        } catch (Throwable t) {
            udp.close();
            Errors.die(t);
        }
    }

    public void close() throws IOException {
        udp.close();
    }

    // Sending
    /**
     * @param id       Id sequence generated by controller.
     *                 The car should reply with confirmation packed containing this id.
     *                 Used for detection of latency and missing packets.
     * @param steering -127 = left,     0 = central, 127 = right
     * @param speed    -127 = backward, 0 = neutral, 127 = forward
     */
    public void controller_update(InetSocketAddress to, byte id, byte steering, byte speed) {
        packetId2millis.put(id, System.currentTimeMillis());
        udp.send(to, new byte[]{CONTROLLER_UPDATE, id, steering, speed});
    }

    public void car_updateReceived(InetSocketAddress to, byte id) {
        udp.send(to, new byte[]{CAR_UPDATE_RECEIVED, id});
    }

    private void both_shout(byte[] shoutBytes) {
        udp.send(new InetSocketAddress(broadcastIp, PORT), shoutBytes, true);
    }

    // Querying
    public Map<InetSocketAddress, String> peer2name() {
        return peer2name.asMap();
    }
}
